# -*- coding: utf-8 -*-
"""복습과제_강민지28.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OcoXY5fzHtaT4afKstrYrHPgKW0g5ll0
"""

import pandas as pd

# 판다스에서 제공하는 두 가지 데이터 구조를 잘 이해해야 한다.
# data frame
# Series
# 첫 시간에 이야기 한 내용들

# seaborn 패키지를 불러서 가지고 오기!
import seaborn as sns

data = sns.load_dataset('titanic')  # load_dataset: 데이터 로드

data

# Pandas 기초문법
print(type(data))  # 데이터 프레임
print(type(data['survived']))   # 하나의 열만을 추출한 경우: Seires
print(type(data.pclass))
print(type(data[['survived', 'fare']])) # 두 개의 열 이상부터는 다시 데이터 프레임
# 2차원은 dataframe, 1차원은 Series

# shape
# 행과 열을 반환
print(data.shape)

# (행, 열): tuple 형태로 반환됨
print(data.shape[0])
print(data.shape[1])

# columns
print(data.columns)    # 컬럼만 추출하고 싶은 경우
print(data.columns[0])  # data.columns도 결국은 list이므로 배열로 추출가능
print(data.columns[3])  # data.columns도 결국은 list이므로 배열로 추출가능
print(data.columns[6])  # data.columns도 결국은 list이므로 배열로 추출가능

# 컬럼만 추출하고 싶은 경우
# list
data_col = list(data.columns)
print(data_col)
print(data_col[0])  # 마찬가지로 리스트 형태의 배열로 추출 가능

# info 기본적인 데이터 프레임의 정보를 알려준다.
data.info()

# 데이터 타입만 가져올 경우
data.dtypes

# 수치형 데이터 기초 통계값
data.describe()

# 수치형 데이터 외 데이터까지 모두 확인 가능
data.describe(include='all')

# head, tail
data.head()     # default 값은 앞의 5개 추출

data.tail()     # default 값은 뒤의 5개 추출

data.head(15)       # 안의 숫자를 통해 추출하고자 하는 행의 수 조정 가능

## "행"과 "열"로 이루어진 데이터 프레임
# 열 기준(column 기준)으로 추출해보기
# 방법1. df[컬럼]
#   >> ['column1']
#   >> [['column1', 'column2']]
# 방법2. df.컬럼

# 문자열이나 공백이 있으면 df.age 이런식으로 하면 에러남 >> 이럴 때는 df[age]로 사용

data['survived']    # 데이터 컬럼 하나만 추출

# 여러 개의 값이 들어가면 리스트에서 [[]] 대괄호 두 개 넣기
print(data[['survived', 'age']])
data_2 = data[['survived', 'age']]
print(data_2)

# 변수처럼 내가 원하는 데이터를 넣을 수 있다.
# 즉, 객체처럼 이용 가능
data_sp = data[['survived', 'age', 'fare']]
data_sp

data

data[['sex', 'class', 'embarked', 'fare']]

data_sae = data[['sex', 'class', 'embarked', 'fare']]
data_sae.head()

## 행 데이터 추출하기!
# 인덱스 기준 문법 이해하기

# loc : 행 인덱스 기준으로 추출(이름으로 추출이 가능),
#       변수의 개념으로 추출도 가능하다! ( -1 끝 값 출력 불가능)
#       "약속한 인덱스 기준으로만 추출 가능"

# iloc : 행 인덱스 기준으로 추출(추출한 인덱스 기준)
#        모든 번호로 추출이 가능 (-1 끝 값 출력 가능)
#        약속한 인덱스 뿐만 아니라 "새롭게 설정한 인덱스 기준으로도 추출가능"

# 슬라이싱, 배열시
# data.iloc[1:40, ['age', 'survived']] 이렇게 접근 불가능
# >> 컬럼명이 아닌, 번호로 추출
# data.iloc[1:40, [3, 8, -1]]

# 리스트 생각하면 index [] 동일
# loc[index]
# iloc[index]

data

print(data.loc[0]) # 첫 행의 모든 값을 추출
print()
print(data.loc[890])

data.iloc[0]

data.iloc[-1]       # iloc은 [-1], 즉, 끝 값 적용가능

# data.loc[-1] >> 오류 발생
# 즉, '-1' 값으로 끝 행의 값 추출 불가

# loc에서 맨 끝 값을 만드는 경우
# 891 값을 불러오기 (가장 끝 값)

# shape >> (행, 열) 의 튜플값이 나온다.
# data.shape[0]: 행을 불러오는 것

num_row = data.shape[0] # 891
num_row
last_idx = num_row - 1   # 새로운 변수 선언

# list로 접근시 loc, iloc 모두 변수로 접근 가능

print(data.loc[last_idx])       # loc은 맨 끝 값을 이렇게 변수로 넣어서도 가능

print(data.iloc[last_idx])   # list로 접근시 loc, iloc 모두 변수로 접근 가능

data.iloc[-1]   # iloc은 맨 마지막 값을 [-1]로 선언가능

# list로 접근시 loc, iloc 모두 변수로 접근 가능

mid_num = 400
data.loc[mid_num]

data.iloc[mid_num]

## 하나의 데이터만 추출하는 것이 아니라 행을 여러가지 추가해서 다양한 행 추출하는 경우!

# [[idx1, idx2, idx3,..., idxn]]

data

data.loc[[1, 10, 20, 30]]

data.iloc[[1, 10, 20, 30]]

# 리스트에서는 iloc이든, loc이든 변수 받아서 출력 가능!

idx = 1
data.loc[[idx, idx+10, idx+20, idx+30]]

idx = 1
data.iloc[[idx, idx+10, idx+20, idx+30]]

'''
    range 슬라이싱을 가지고 -> 동일하게 적용가능.
    loc, iloc 슬라이싱을 통해서 데이터 범위 range 지정가능.
    [:] 전체
    [시작점:끝점:증가폭] range함수와 동일하게 추출할 수 있다!
'''

data.loc[::2]

data.iloc[::3]

data.iloc[::10]

data_sp = data.loc[3:50:4]

data_sp

# data_sp.loc[2]
# loc은 지정한 index에 대해서만 추출 가능
# 새롭게 만든 index에 대해서는 추출 불가

data_sp.iloc[2]
# iloc은 새롭게 지정한 index에 대해서도 추출 가능

# 행과 열로 접근 가능
data['age'].loc[2]

# 슬라이싱과 컬럼을 통해 접근하기
'''
    loc, iloc에 가장 큰 차이 중 하나 ( 슬라이싱/배열 컬럼에 대한 접근 )
    iloc은 모든 컬럼을 숫자로만 접근한다.

    **
    python 대부분은 [행, 열]
    tt.loc[행,열]

'''
data.loc[1:50, ['age']]

# data.iloc[51:100, [문자로 접근 X]]
# data.iloc[51:100, [index 숫자로만 접근 가능]]
data.iloc[51:100, [3, 4, 5]] # * [행, 열]
# 3: age
# 4: sibsp
# 5: parch

# Vs. loc은 슬라이싱/배열로 접근시 이름으로 접근 가능
data.loc[:30, ['age', 'survived']]
# 1차원 [] 두 개 컬럼이상이면 그대로 추가하면 된다.

# 컬럼에 대한 접근은 iloc 숫자로 접근해야 한다. (숫자는 컬럼의 인덱스를 뜻함)
# data.iloc[:30:2, ['age', 'survived']]

# data.loc[:30, [3, 5]]
# index 번호로 접근시 오류 발생

# data.iloc[1:40, ['age', 'survived']]
# iloc은 column 명으로 접근시 오류 발생

data.iloc[1:40, [3, 8, -1]]
# # iloc은 넘버로만 지정해서 접근해야 한다

data.iloc[1:50, [3, 6, 10]]
data.iloc[1:50, [3, 6, 10]]['age']
data.iloc[1:50, [3, 6, 10]]['age'].loc[10]

# 계속해서 객체에 담아서 진행할 수 있다.

# data2 = data.iloc[51:100, ['age', 'survived', 'fare']]
data2 = data.loc[51:100, ['age', 'survived', 'fare']]   # [행, 열]

data3 = data2['fare']
data3.loc[51]

# 인덱스 5번 째 값중에서 sex와 embarked를 추출한다!
data.loc[5][['sex', 'embarked']]

data[['sex', 'embarked']].iloc[5]

# Q.여기서 iloc 대신 loc을 쓰면 에러가 뜨는데 왜그런건가요? tt.loc[1:50,[3,4]]
# data.loc[1:50,[3,4]] >> loc의 슬라이싱 + 배열에서, 컬럼명을 숫자가 아닌 이름으로 사용해야함.
data.iloc[1:50,[3,4]]

## range 이용하여 변수화 하여 데이터 추출
rn = range(0,100,3)
rn

rn = list(range(0,100,3))
rn

# 인덱스처럼 넣을 수 있다.
data.loc[rn]

data.iloc[rn]   # 슬라이싱 + 배열 아닌 곳에서는 문자열 넣어도 무방

rn_col = list(range(0,10,2))
rn_col

data.iloc[:,rn_col] # rn_col은 열(column) 추출로 사용
# ** [ , ] 컴마 기준 행/열
# 컬럼을 range로 list 넣은 후 원하는 컬럼만 데이터 추출 가능
# iloc 은 새로운 index 가능

## 기본적인 통계치를 구하기!
'''
- 행과 열을 접근하는 법을 이해했으니 -> 기초통계치에 대한 값을 구하는 걸 배우고 -> 응용하자!
- 판다스에 제공하는 mean, sum, std.. 기초통계들 사용 가능
- 넘파이에서 제공하는 np.mean, np.argmax, np.std 등도 사용 가능하다.
'''

data

# fare 요금이니 통계치로 보기에 적정
# 평균, median, sum 값?
data['fare'].mean()

data.fare.sum()

data.fare.count()

data.fare.median()

# 평균
data.fare.sum()/data.fare.count()

## 한 depth씩 더 들어가서 값을 구하자!
# pclass별로 평균 fare 얼마입니까?
# sex별로 평균 age 얼마입니까?
# 엑셀에서 피벗 개념으로 값 계산할 수 있다.
# groupby 그룹으로 묶어서 계산하는 것
# groupby('그룹을 묶을 컬럼')['통계치를 볼 컬럼'].원하는 통계치()
import numpy as np

data.groupby('sex')['age'].mean()

data.groupby('pclass')['fare'].mean()

data.groupby('sex')['fare'].mean()

data.groupby('embark_town')['fare'].mean()

data.groupby('embarked')['sex'].count()

# 재밌는 것!
data.groupby('sex')['survived'].sum() # 전체 생존자 중에서 여성이 233명 생존, 남성이 109명 생존

# survived는 생존자가 1로 / 비생존자가 0으로 표시되므로 합을 계산하면 -> 생존자

data.groupby('sex')['fare'].mean()

# 두 개의 값을 볼 수도 있다.
data.groupby('sex')[['fare','age']].mean()

# 최대 값의 '인덱스' 반환
np.argmax(data['fare'])

max_fare_idx = np.argmax(data['fare'])  # 행의 값
data.loc[max_fare_idx]

# 최소 값의 '인덱스' 반환
min_age_idx = np.argmin(data['age'])
data.iloc[min_age_idx]

data.groupby('pclass')['fare','age'].mean()

# ['fare','age'] 두 값을 묶을 땐 [[]] 두 개로 표현해주기
data.groupby('pclass')[['fare','age']].mean()

'''
- 원하는 값을 접근하기 위해서, 또는 추출하기 위해서?
- 데이프레임을 어떤 식으로 접근해야 하는가?

- 행과 열로 접근
- 열과 행으로 접근해도 된다.

Q1.  - survied, fare, class 컬럼의 2~40개 인덱스 데이터를 추출하고 싶다!
'''

data.loc[2:40,['survived', 'fare', 'class']]   # [행, 열] >> 슬라이싱/배열 사용

# 열 >> 행
data[['survived', 'fare', 'class']].loc[2:40]

# 판다스의 데이터 추출 원리를 보면
# data.loc[2:40, ['survived', 'fare', 'age']].
data[['survived', 'fare', 'age']].loc[2:40]['age'].mean()

'''
## 데이터 분석에 필요한 기초 문법(2)
- query()
- sort_values()
- groupby()
- assign(), lambda
- agg()
- merge() - 따로 병합은 1시간 동안 추가로 진행할 예정
- concat() - 따로 병합은 1시간 동안 추가로 진행할 예정
- str() -> 1~2시간 자연어처리 진행하면서 할 예정
- 시계열 ->1~2시간정도 따로 시계열 데이터 전처리를 배울 예정
'''

'''
- query()
- 데이터를 추출하기 위한 조건
- ''내가 원하는 데이터를 추출하기 위해서 추가적으로 사용하는 문법''

- e.g. embarked = s인경우? , alone = Ture 참인 경우?, fare > 평균이상인경우?
- 요소의 특정값을 접근해서 데이터를 추출하는 케이스

- tt.query('요구조건')
'''

data

data.query('pclass == 3')
# data.query('''pclass == 3''')

data.query(''' who == 'man' ''')

data.query(''' sex != "male" ''')

# 수치형 데이터로 접근해 보기!
data.query(''' age <= 35 ''')   # 해당 age 이하인 경우 추출 가능

fare_mean = data['fare'].mean()
fare_mean

type(fare_mean)

data.query(''' fare >= fare_mean ''')

#### 질문 ####
# query는 변수로 범위 지정은 안되는건지?!

'''
- 논리연산자 이용해서 다양한 케이스를 추가할 수 있다.
- and, or
'''

data.query('age <= 35 and sex == "female"')

data.query('age >= 50 or embarked == "S"')

data['fare'].mean()

# 문자, 숫자 다 같이 조건에 넣어서 진행해 보자!
data.query('sex == "male" and fare >= 32.204207968574636')

'''
- 우리가 지금까지 배운 것들을 다 같이 응용해보기!
- 컬럼, 인덱스 기준으로 데이터를 추출할 수 있다.
- query()이용해서 해당 데이터의 요소의 값의 기준으로 데이터를 추출할 수 있다!



- ### Q1. embarked != "S" and fare >=32.204207968574636 and age<30 이 승객들의 생존자는?
- 생존한 경우 -> 1을 다 더하면 생존자

- ### Q2. pclass == 1 and fare >=100 and sex==female 이 승객들의 생존자는?
- 생존한 경우 -> 1을 다 더하면 생존자

'''

'''
- ### Q1. embarked != "S" and fare >=32.204207968574636 and age<30 이 승객들의 생존자는?
- 생존한 경우 -> 1을 다 더하면 생존자
'''

data_1 = data.query('embarked != "S" and fare >=32.204207968574636 and age<30 and survived == 1')

data_1['survived'].sum()

'''
- ### Q2. pclass == 1 and fare >=100 and sex==female 이 승객들의 생존자는?
- 생존한 경우 -> 1을 다 더하면 생존자
'''

data_2 = data.query('pclass == 1 and fare >=100 and sex=="female" and survived == 1')

data_2['survived'].sum()

