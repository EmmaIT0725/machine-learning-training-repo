# -*- coding: utf-8 -*-
"""복습과제_강민지_28.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OtzQhjzP5W6vv90q6kV2JP98y5fGu7x_
"""

import seaborn as sns
import pandas as pd

dt = sns.load_dataset('titanic')

dt

'''
    저번시간에 이어 계속해서 데이터 분석에 필요한 기초 문법 진행

    sort 순서 정렬하기
    sort_values(col1), 오름 ,내림 차순 정렬
    내림차순 하는 법?
    sort_values(col1, ascending=False, True)
'''

# 디폴트가 오름차순
dt.sort_values('fare')

dt.sort_values('age')

dt.sort_values(['age', 'pclass'])       # 이 때는 'age'가 우선순위

dt.sort_values(['pclass', 'age'])       # 이 때는 'pclass'가 우선순위

# ascending = False : 내림차순
dt.sort_values('pclass', ascending= False)

# 여러 개 기준으로 하는 경우
# age , fare 두 가지 경우

dt.sort_values(['fare','age', 'pclass']) # fare 1순위, age 2순위 pclass 3순위

dt.sort_values(['fare','age', 'pclass'], ascending=[False, True, True]) # fare 1순위, age 2순위 pclass 3순위
# ascending 적용될 때도 'fare'이 1순위로 적용된다.

### 파생변수 여러 개 만들어보기
# 파생변수라 함은, column의 열로 들어갈 수 있는 변수

## 수업과 다르게 코드짜보기
# pclass가 1,2,3인 경우에 따라서 반복문과 if문을 이용해서 Top, Middle, Low 매핑하기!
# loc은 [] 사용 : 한 행씩 받아서 판단할 것
# 따라서 출력할 값도 한 행씩 받아서 출력할 것

# if문 ()로 묶어주기

# 파생변수로 만드는 column 값 초기화해주기
dt['pclass_level'] = 0
for i in range(len(dt)):
    if (dt['pclass'].loc[i] == 1):
#       dt['pclass_level'] = 'Top' >>> 한 행씩 받아서 값을 도출하지 못함
        dt['pclass_level'].loc[i] = 'Top'
    elif (dt['pclass'].loc[i] == 2):
        dt['pclass_level'].loc[i] = 'Middle'
    else:
        dt['pclass_level'].loc[i] = 'Low'

dt

dt.pclass.value_counts()

dt['pclass_level'].value_counts()

### 수업시간에 했던 코드
## 성별이 남성인 경우 여성인 경우에 따라서 반복문과 if문을 이용해서 0, 1 매핑하기!
## 값을 지정해서 들어가면 [], loc, iloc으로 값을 찾았다.
## 여성과 남성인지를 확인하기 위해서
##dt.sex.loc[3]
##남성 0 여성이면 1

##이런 새로운 변수를 만들 경우 파생변수를 하나 만들어서 진행할 수 있다.

# 단, if 돌릴 때 i말고 다른 변수 j.. 사용하기
dt['sex_onehot']= 0
for j in range(len(dt)):
    if dt.sex.loc[j] == 'male':
        dt['sex_onehot'].loc[j] = 0
    elif dt.sex.loc[j]== 'female':
        dt['sex_onehot'].loc[j] = 1

dt

dt.sex.value_counts()

dt.sex_onehot.value_counts()

# 필수과제1_강민지_28.ipynb로 제출

# 요금변수에 *100 단위를 맞춘다.

dt.fare * 100
# 바로 브로드캐스팅이 되어서 시리즈에서 연산이 된다.

dt['fare_100'] = dt.fare * 100

## 파생변수 만들 수 있는 함수
# assign()함수를 이용해서 만들 수 있다.
# assign(파생변수 = np.where(조건, 조건을 만족할 때 출력될 파생변수 값,
#                               조건을 만족하지 않을 때 출력될 파생변수 값))

# np.where은 조건을 만족하는 index를 출력해주는 함수
# 즉, assign() 함수를 통해서는 해당 조건을 만족하는 인덱스에
# 조건을 만족하면 출력되는 파생변수값이 도출됨

# 이 때 column 명은 파생변수명과 동일

import numpy as np
# 넘파이에서 제공하는 np.where 함수를 이용해서 인덱싱하여 해당 값에 조건에 맞는 값을 대입
# 즉, np.where 함수는 주어진 조건을 만족하는 행의 인덱스를 도출함

# np.where을 여러 개 사용해서 assign 함수 사용하기
# 특히 값이 2개로 매핑되지 않고, 3개 이상인 경우
dt.assign(pclass_level = np.where(dt['pclass'] == 1, 'Top',
                                    np.where(dt['pclass'] == 2, 'Middle',   # 'Top'이 아닌 경우 다시 np.where을 통해 조건을 만족하는 행의 인덱스를 찾음
                                             'Low')))

# 변수에 저장하고 싶으면

dt1 = dt.assign(pclass_level = np.where(dt['pclass'] == 1, 'Top',
                                    np.where(dt['pclass'] == 2, 'Middle',   # 'Top'이 아닌 경우 다시 np.where을 통해 조건을 만족하는 행의 인덱스를 찾음
                                             'Low')))

dt1

# 단순한 np.where / assign() 함수 사용하기
dt.assign(fare_level = np.where(dt['fare'] >= 50, 'H', 'L'))

# np.where은 조건에 맞는 인덱스를 호출하는 함수
np.where(dt['sex'] == 'female')

# 조건에 맞는 값(내가 지정한 파생변수 값)을 집어넣겠다!
np.where(dt['sex'] == 'female', 'F', 'M')

dt.assign(sex_level = np.where(dt['sex'] == 'female', 'F', 'M'))

# dt.assign(sex_level = np.where(dt['sex'] == 'female', 'F', 'M'))
# 위의 코드가 dt에 반영되지는 않음

# 따라서 새로운 변수에 저장하기
dt1 = dt.assign(sex_level = np.where(dt['sex'] == 'female', 'F', 'M'))

# 값 맞는지 확인해보기
dt1['sex'].loc[5]

dt1['sex_level'].loc[5]

## lambda를 사용해서도 가능
double = lambda x: x*2

# 함수처럼 사용 가능

double(5)

dt

dt.assign(fare_2 = lambda x: x['fare']*2)

## lambda 더 사용해보기
fare_mean = lambda x: x['fare'].mean()

fare_mean(dt)

dt.assign(fare_std = lambda x : x['fare'].std())

dt.assign(survived_count = lambda x : x['survived'].sum())

'''
## group by

- 집계하는 것
- 기준 컬럼을 가지고 통계치를 보고 싶은 컬럼의 값을 볼 수 있다.
- Groupby 하나의 기준 컬럼의 그룹으로 만든다.
'''

# pclass : 1,2,3 등급으로 나누어져 있음
dt.groupby('pclass')
# 'pclass'에 따라 dt를 나누어 놓은 것
# 즉, dt 중 pclass == 1인 데이터 쫙~ / pclass == 2인 데이터 쫙~ / pclass == 3인 데이터 쫙~
# 다시 말하면 pclass = 1,2,3 인 것에 따라 그룹이 만들어진다.

pclass_grouped = dt.groupby('pclass')

'''
pclass_grouped 객체에는
그룹 이름(여기서는 'pclass'의 값)과 해당 그룹에 속한 데이터로
이루어진 튜플이 포함되어 있다.
각각의 튜플은 (그룹 이름, 해당 그룹의 데이터) 형식.

아! 튜플형식으로 되어있다.
'''

pclass_grouped
# 각각의 튜플은 (그룹 이름, 해당 그룹의 데이터) 형식.

# 값 도출된 것 확인하기 >>> 한 행씩 받아서 확인하기
# 코드 자세하게 이해하기

# 각각의 튜플은 (그룹 이름, 해당 그룹의 데이터) 형식.
# i는 'pclass' 열의 고유한 값(즉, 1, 2, 3 등급)을 나타내며,
# j는 해당 그룹에 속한 데이터셋
for i, j in pclass_grouped:
    print(i)
    print(j.head(5))

sex_gr = dt.groupby('sex')
# 마찬가지로 (그룹이름, 해당 그룹의 데이터) 형식의 튜플 값으로 존재

for i, j in sex_gr:
    print(i)
    print(j.head(3))

'''
groupby를 적용하면 결과는
DataFrameGroupBy 또는 SeriesGroupBy 객체로 반환

이 객체는 그룹 이름(또는 그룹 키)과 해당 그룹에 속한 데이터를 함께 저장
그룹 이름과 해당 그룹에 속한 데이터가 튜플 형태로 반환.
이 튜플의 첫 번째 요소는 그룹 이름이고, 두 번째 요소는 해당 그룹에 속한 데이터

그룹화된 데이터를 직접 확인하고 싶다면,
DataFrameGroupBy 또는 SeriesGroupBy 객체에 .groups 속성을 사용하여
 그룹화된 결과를 딕셔너리 형태로 확인가능
'''
sex_gr.groups

sex_gr.groups['female']
sex_gr.groups['male']

## groupby는 딕셔너리 형태로 반환 ##

pclass_gr = dt.groupby('pclass')

## groupby는 딕셔너리 형태로 반환 ##
pclass_gr.groups

# 키 반환
pclass_gr.groups.keys()

# 값 반환
pclass_gr.groups.values()

list(pclass_gr)

# pclass_gr.keys()
list(pclass_gr.groups.keys())

list(pclass_gr.groups.values())



# for i, j in pclass_gr.groups:
#     print(i)
#     print(j.head(5))

## 카페에 질문 올린 것 기반으로 다시 생각해보기
# pclass_gr
# pclass_gr.groups

# get_group (내가 원하는 그룹)

pclass_gr.get_group(1)

sex_gr = dt.groupby('sex')

sex_gr.get_group('female')

## groupby를 두 개 이상 진행하게 되면
# []

grouped = dt.groupby(['embark_town', 'sex'])

grouped

# groups
grouped.groups   # 여전히 딕셔너리 형태

for i, j in grouped:
    print(i)        # 그룹의 키(key)값을 받아줌
    print(j.tail(5))    # 그룹의 value 값을 받아줌

grouped.mean()

grouped.std()

# groupby agg 함수를 넣어서 통계치 살펴보기
# groupby 그룹을 묶고 내가 원하는 통계치들을 정리해서 볼 수 있다.
# dt.groupby('그룹할 컬럼').agg(변수명 = ('기준컬럼', '기준컬럼을 볼 통계치'),
#                                           추가..)

dt

dt.groupby('pclass').agg(survived = ('survived', 'sum'))

dt.groupby('sex').agg(fare_std = ('fare', 'std'))

# 여러 개의 통계치로 나타내기
dt.groupby('embarked').agg(em_survived = ('survived', 'sum'),
                                em_fare_mean = ('fare', 'mean'),
                                    em_fare_std = ('fare', 'std'),
                                        em_sex_num = ('sex', 'count'))

# 나만의 튜닝으로 만든 함수를 agg에 넣어서 값을 계산하자
def min_max(x):
    return x.max() - x.min()

min_max(dt['age'])

dt.groupby('embark_town').agg(min_max)
                                    # 원래는 기준값이 되는 컬럼명과
                                    # 통계치값 넣어줌

# 1개의 컬럼의 2개 이상의 통계치를 볼 때
# [ ]
# dt.groupby('embarked').agg(fare_std = ('fare', 'std'))  일반적인 것
# 1개의 컬럼의 2개 이상의 통계치를 볼 경우에는 딕셔너리 형태

dt.groupby('embarked').agg({'fare' : ['mean', 'std', 'var']})

# 1개의 컬럼의 2개 이상의 통계치를 볼 경우에는 딕셔너리 형태
dt.groupby('sex').agg({'age' : ['mean', 'std', 'var']})

dt.groupby('pclass').agg({'fare' : ['mean', 'std', 'var']})

dt.groupby('pclass').agg({'age' : ['mean', 'std', 'var']})

'''
## 데이터 병합

- concat, merge
- concat : 덩어리와 덩어리가 합쳐진다. df1, df2 합쳐진다. 날 것 그대로
    - 행으로 붙이는 것 df1 + df2
    - 열로 붙이는 것
    - df1
    - '+'
    - df2
- merge : join 형태, left, outer, right join 개념
'''

# 데이터 프레임으로 만들어서 이해해보기
# 딕셔너리 형태로 저장
test1 = pd.DataFrame({'번호' : [1, 2, 3, 4, 5],
                      '이름' : ['강민지', '강민철', '김재웅', '이은혜', '장유신']})
test2 = pd.DataFrame({'번호' : [1, 2, 3, 4, 5],
                      '벌점현황' : [0, 4, 50, 2, 1]})

#pd.merge(왼쪽컬럼(기준), 오른쪽컬럼(그다음), how='병합방법', on='공통기준컬럼')
# left_on, right_on 지정할 수 있음

pd.merge(test1, test2, how='inner', on='번호')

pd.merge(test2, test1, how='inner', on='번호')

pd.merge(test1, test2, how='left', on='번호')

test1

test2

# pd.concat을 이용해서 데이터 병합
# pd.concat(axis = 1,0 에 따라 달라진다.)
# 1 : 오른쪽으로 붙여진다. [열 기준]
# 0 : 컬럼별로 붙여진다.

# pd.concat(test1, test2)
pd.concat([test1, test2])   # 디폴트값: axis = 0

pd.concat([test1, test2], axis=1)

### 컬럼수 늘려서 데이터 프레임 합쳐보기
test3 = pd.DataFrame({'번호' : [1, 2, 3, 4, 5],
                       '이름' : ['강민지', '김재웅', '강민철', '장유신', '이은혜'],
                       '성별' : ['여', '남', '남', '여', '여'],
                       '직업' : ['학생', '변호사', '병원원무', '라디오', '변호사']})

test4 = pd.DataFrame({'생일' : ["07-25", "08-06", "09-02", "02-05", "11-15"],
                       '이름' : ['강민지', '김재웅', '강민철', '장유신', '이은혜'],
                       '취미' : ['코딩', '헬스', '달리기', '독서', '드라마'],
                       '거주지' : ['대구', '시애틀', '대구', '진주', '서울']})

pd.merge(test3, test4, how='inner', on = '이름')

# concat은 [] 사용해서 [test3, test4]
pd.concat([test3, test4], axis=1)

# concat은 [] 사용해서 [test3, test4]
pd.concat([test3, test4], axis=0)

'''
    value_counts()

    변수들의 카운팅을 진행하는 문법
    tt.컬럼.value_counts()

    value_counts(normalize= True,False) 카운팅 총섬 1 나누는 것
    value_counts(ascending= True,False) 카운트 숫자를 기준으로 내림 오름차순
'''

dt

dt['sex'].value_counts()

dt['age'].value_counts(ascending=True)

dt['survived'].value_counts()
# 즉 생존이 342명

dt['fare'].value_counts()

dt['fare'].value_counts(normalize=True)

